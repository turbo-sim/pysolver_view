
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pysolver_view.optimization &#8212; pysolver_view v0.6.2 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../../_static/documentation_options.js?v=e368b39a"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pysolver_view/optimization';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">pysolver_view v0.6.2 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../source/introduction.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/tutorial_optimization.html">Tutorial: Optimization problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/tutorial_nonlinear_system.html">Tutorial: Nonlinear systems</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../source/api/modules.html">API Reference</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../source/api/pysolver_view.nonlinear_system.html">Nonlinear systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../source/api/pysolver_view.nonlinear_system_problems.html">Nonlinear system problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../source/api/pysolver_view.optimization.html">Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../source/api/pysolver_view.optimization_wrappers.html">Optimization wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../source/api/pysolver_view.optimization_problems.html">Optimization problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../source/api/pysolver_view.numerical_differentiation.html">Numerical differentiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../source/api/pysolver_view.pysolver_utilities.html">Package utilities</a></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for pysolver_view.optimization</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">MaxNLocator</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">numerical_differentiation</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">optimization_wrappers</span> <span class="k">as</span> <span class="n">_opt</span>
<span class="kn">from</span> <span class="nn">.pysolver_utilities</span> <span class="kn">import</span> <span class="n">savefig_in_formats</span><span class="p">,</span> <span class="n">validate_keys</span>

<span class="c1"># Define valid libraries and their corresponding methods</span>
<span class="n">OPTIMIZATION_LIBRARIES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;scipy&quot;</span><span class="p">:</span> <span class="n">_opt</span><span class="o">.</span><span class="n">minimize_scipy</span><span class="p">,</span>
    <span class="s2">&quot;pygmo&quot;</span><span class="p">:</span> <span class="n">_opt</span><span class="o">.</span><span class="n">minimize_pygmo</span><span class="p">,</span>
    <span class="s2">&quot;pygmo_nlopt&quot;</span><span class="p">:</span> <span class="n">_opt</span><span class="o">.</span><span class="n">minimize_nlopt</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">VALID_LIBRARIES_AND_METHODS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;scipy&quot;</span><span class="p">:</span> <span class="n">_opt</span><span class="o">.</span><span class="n">SCIPY_SOLVERS</span><span class="p">,</span>
    <span class="s2">&quot;pygmo&quot;</span><span class="p">:</span> <span class="n">_opt</span><span class="o">.</span><span class="n">PYGMO_SOLVERS</span><span class="p">,</span>
    <span class="s2">&quot;pygmo_nlopt&quot;</span><span class="p">:</span> <span class="n">_opt</span><span class="o">.</span><span class="n">NLOPT_SOLVERS</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="OptimizationSolver">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver">[docs]</a>
<span class="k">class</span> <span class="nc">OptimizationSolver</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Solver class for general nonlinear programming problems.</span>

<span class="sd">    The solver is designed to handle constrained optimization problems of the form:</span>

<span class="sd">    Minimize:</span>

<span class="sd">    .. math::</span>
<span class="sd">        f(\mathbf{x}) \; \mathrm{with} \; \mathbf{x} \in \mathbb{R}^n</span>

<span class="sd">    Subject to:</span>

<span class="sd">    .. math::</span>
<span class="sd">        c_{\mathrm{eq}}(\mathbf{x}) = 0</span>
<span class="sd">    .. math::</span>
<span class="sd">        c_{\mathrm{in}}(\mathbf{x}) \leq 0</span>
<span class="sd">    .. math::</span>
<span class="sd">        \mathbf{x}_l \leq \mathbf{x} \leq \mathbf{x}_u</span>

<span class="sd">    where:</span>

<span class="sd">    - :math:`\mathbf{x}` is the vector of decision variables (i.e., degree of freedom).</span>
<span class="sd">    - :math:`f(\mathbf{x})` is the objective function to be minimized. Maximization problems can be casted into minimization problems by changing the sign of the objective function.</span>
<span class="sd">    - :math:`c_{\mathrm{eq}}(\mathbf{x})` are the equality constraints of the problem.</span>
<span class="sd">    - :math:`c_{\mathrm{in}}(\mathbf{x})` are the inequality constraints of the problem. Constraints of type :math:`c_{\mathrm{in}}(\mathbf{x}) \leq 0` can be casted into :math:`c_{\mathrm{in}}(\mathbf{x}) \geq 0` type by changing the sign of the constraint functions.</span>
<span class="sd">    - :math:`\mathbf{x}_l` and :math:`\mathbf{x}_u` are the lower and upper bounds on the decision variables.</span>

<span class="sd">    The class interfaces with various optimization methods provided by libraries such as `scipy` and `pygmo` to solve the problem and provides a structured framework for initialization, solution monitoring, and post-processing.</span>

<span class="sd">    This class employs a caching mechanism to avoid redundant evaluations. For a given set of independent variables, x, the optimizer requires the objective function, equality constraints, and inequality constraints to be provided separately. When working with complex models, these values are typically calculated all at once. If x hasn&#39;t changed from a previous evaluation, the caching system ensures that previously computed values are used, preventing unnecessary recalculations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    problem : OptimizationProblem</span>
<span class="sd">        An instance of the optimization problem to be solved. The problem should be defined</span>
<span class="sd">        in physical space, with its own bounds and (optionally) analytic derivatives.</span>
<span class="sd">    library : str, optional</span>
<span class="sd">        The library to use for solving the optimization problem (default is &#39;scipy&#39;).</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        The optimization method to use from the specified library (default is &#39;slsqp&#39;).</span>
<span class="sd">    tolerance : float, optional</span>
<span class="sd">        Tolerance for termination. The minimization algorithm sets some solver-specific tolerances</span>
<span class="sd">        equal to tol. (default is 1e-6)</span>
<span class="sd">    max_iterations : int, optional</span>
<span class="sd">        Maximum number of iterations for the optimizer (default is 100).</span>
<span class="sd">    extra_options : dict, optional</span>
<span class="sd">        A dictionary of solver-specific options that prevails over &#39;tolerance&#39; and &#39;max_iterations&#39;</span>
<span class="sd">    derivative_method : str, optional</span>
<span class="sd">        Method to use for derivative calculation (default is &#39;2-point&#39;).</span>
<span class="sd">    derivative_abs_step : float, optional</span>
<span class="sd">        Finite difference absolute step size to be used when the problem Jacobian is not provided. Default depends on calculation method.</span>
<span class="sd">    problem_scale : float or None, optional</span>
<span class="sd">        Scaling factor used to normalize the problem. This parameter controls the transformation</span>
<span class="sd">        of physical variables into a normalized domain. Specifically, for a physical variable x,</span>
<span class="sd">        with lower and upper bounds lb and ub, the normalized variable is computed as:</span>

<span class="sd">            x_norm = problem_scale * (x - lb) / (ub - lb)</span>

<span class="sd">        - If a numeric value is provided (e.g. 1.0, 10.0, etc.), the problem is scaled accordingly.</span>
<span class="sd">          Increasing problem_scale reduces the relative step sizes in the normalized space during</span>
<span class="sd">          line searches, which can improve convergence by making the optimization less aggresive.</span>
<span class="sd">          The rationale for the scaling is that the initial line search step size of many solvers is 1.0.</span>
<span class="sd">        - If set to None, no scaling is applied and the problem is solved in its original physical units.</span>
<span class="sd">          This might be preferred if the problem is already well-conditioned or if the user wishes to</span>
<span class="sd">          preserve the exact scale of the original formulation.</span>

<span class="sd">    print_convergence : bool, optional</span>
<span class="sd">        If True, displays the convergence progress (default is True).</span>
<span class="sd">    plot_convergence : bool, optional</span>
<span class="sd">        If True, plots the convergence progress (default is False).</span>
<span class="sd">    plot_scale_objective : str, optional</span>
<span class="sd">        Specifies the scale of the objective function axis in the convergence plot (default is &#39;linear&#39;).</span>
<span class="sd">    plot_scale_constraints : str, optional</span>
<span class="sd">        Specifies the scale of the constraint violation axis in the convergence plot (default is &#39;linear&#39;).</span>
<span class="sd">    logger : logging.Logger, optional</span>
<span class="sd">        Logger object to which logging messages will be directed. Logging is disabled if `logger` is None.</span>
<span class="sd">    update_on : str, optional</span>
<span class="sd">        Specifies if the convergence report should be updated based on new function evaluations or gradient evaluations (default is &#39;gradient&#39;, alternative is &#39;function&#39;).</span>
<span class="sd">    callback_functions : list of callable or callable, optional</span>
<span class="sd">        Optional list of callback functions to pass to the solver.</span>
<span class="sd">    plot_improvement_only : bool, optional</span>
<span class="sd">        If True, plots only display iterations that improve the objective function value (useful for gradient-free optimizers) (default is False).</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    solve(x0):</span>
<span class="sd">        Solve the optimization problem using the specified initial guess `x0`.</span>
<span class="sd">    fitness(x):</span>
<span class="sd">        Evaluates the optimization problem objective function and constraints at a given point `x`.</span>
<span class="sd">    gradient(x):</span>
<span class="sd">        Evaluates the Jacobians of the optimization problem at a given point `x`.</span>
<span class="sd">    print_convergence_history():</span>
<span class="sd">        Print the final result and convergence history of the optimization problem.</span>
<span class="sd">    plot_convergence_history():</span>
<span class="sd">        Plot the convergence history of the optimization problem.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">problem</span><span class="p">,</span>
        <span class="n">library</span><span class="o">=</span><span class="s2">&quot;scipy&quot;</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;slsqp&quot;</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">max_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">extra_options</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">derivative_method</span><span class="o">=</span><span class="s2">&quot;2-point&quot;</span><span class="p">,</span>
        <span class="n">derivative_abs_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">problem_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">print_convergence</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">plot_convergence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">plot_scale_objective</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">plot_scale_constraints</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">update_on</span><span class="o">=</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span>
        <span class="n">callback_functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_improvement_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">tolerance_check_cache</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="c1"># Initialize class variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">problem</span> <span class="o">=</span> <span class="n">problem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">print_convergence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span> <span class="o">=</span> <span class="n">plot_convergence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_scale_objective</span> <span class="o">=</span> <span class="n">plot_scale_objective</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_scale_constraints</span> <span class="o">=</span> <span class="n">plot_scale_constraints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">library</span> <span class="o">=</span> <span class="n">library</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derivative_method</span> <span class="o">=</span> <span class="n">derivative_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derivative_abs_step</span> <span class="o">=</span> <span class="n">derivative_abs_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback_functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_callback</span><span class="p">(</span><span class="n">callback_functions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback_function_call_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_improvement_only</span> <span class="o">=</span> <span class="n">plot_improvement_only</span>
        
        <span class="c1"># Tolerance to check if design variables are the same as in previous fitness call</span>
        <span class="k">if</span> <span class="n">tolerance_check_cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tolerance_cache</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tolerance_cache</span> <span class="o">=</span> <span class="n">tolerance_check_cache</span>

        <span class="c1"># Validate library and method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_library_and_method</span><span class="p">()</span>

        <span class="c1"># Define options dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolerance&quot;</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">,</span> <span class="s2">&quot;max_iterations&quot;</span><span class="p">:</span> <span class="n">max_iterations</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">|</span> <span class="n">extra_options</span>

        <span class="c1"># Set scaling for the optimization problem (define at the solver, rather than problem level)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">problem_scale</span> <span class="o">=</span> <span class="n">problem_scale</span>

        <span class="c1"># Auto-generate design variable names if not provided</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="p">,</span> <span class="s2">&quot;variable_names&quot;</span><span class="p">):</span>
            <span class="n">n_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">variable_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;design_variable_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vars</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="c1"># Check for logger validity</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The provided logger is not a valid logging.Logger instance.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Check for valid display_on value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_on</span> <span class="o">=</span> <span class="n">update_on</span>
        <span class="k">if</span> <span class="n">update_on</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="s2">&quot;gradient&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid value for &#39;update_on&#39;. It should be either &#39;function&#39; or &#39;gradient&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Rename number of constraints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_nec</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_ineq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_nic</span><span class="p">()</span>

        <span class="c1"># Initialize variables for convergence report</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_final</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_final</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_last_norm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grad_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_count_tot</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">success</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_report</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elapsed_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_history</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;grad_count&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;func_count&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;func_count_total&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;objective_value&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;constraint_violation&quot;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s2">&quot;norm_step&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="c1"># Initialize dictionary for cached variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;c_eq&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;c_ineq&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;x_jac&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;f_jac&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;c_eq_jac&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;c_ineq_jac&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;fitness&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;gradient&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_validate_library_and_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Check if the library is valid</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">VALID_LIBRARIES_AND_METHODS</span><span class="p">:</span>
            <span class="n">error_message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid optimization library &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="si">}</span><span class="s2">&#39;. </span><span class="se">\n</span><span class="s2">Available libraries:</span><span class="se">\n</span><span class="s2">   - &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">   - &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">VALID_LIBRARIES_AND_METHODS</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>

        <span class="c1"># Check if the method is valid for the selected library</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">VALID_LIBRARIES_AND_METHODS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">]:</span>
            <span class="n">error_message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid method &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; for library &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="si">}</span><span class="s2">&#39;. </span><span class="se">\n</span><span class="s2">Valid methods are:</span><span class="se">\n</span><span class="s2">   - &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">   - &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">VALID_LIBRARIES_AND_METHODS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">])</span>
                <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate the callback functions argument.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">callback</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">callback</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">non_callable_items</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">callback</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">item</span><span class="p">)]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">non_callable_items</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">callback</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;All elements in the callback list must be callable functions. Non-callable items: </span><span class="si">{</span><span class="n">non_callable_items</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;callback_func must be a function or a list of functions. Received type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">callback</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>

<div class="viewcode-block" id="OptimizationSolver.solve">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver.solve">[docs]</a>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the optimization problem using the specified library and solver.</span>

<span class="sd">        This method initializes the optimization process, manages the flow of the optimization,</span>
<span class="sd">        and handles the results, utilizing the solver from a specified library such as scipy or pygmo.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x0 : array-like, optional</span>
<span class="sd">            Initial guess for the solution of the optimization problem.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x_final : array-like</span>
<span class="sd">            An array with the optimal vector of design variables</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize convergence plot</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_plot_convergence_callback</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">initialize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Get start datetime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_datetime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">_%H-%M-%S&quot;</span><span class="p">)</span>

        <span class="c1"># Start timing with high-resolution timer</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

        <span class="c1"># Normalize the problem as the very first thing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">clip_to_bounds</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">scale_physical_to_normalized</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="c1"># Print report header</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_header</span><span class="p">()</span>

        <span class="c1"># Define new problem with anonymous methods (avoid problems when Pygmo creates a deep copy)</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">_PygmoProblem</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Print initial guess evaluation when using gradient</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_on</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_print_convergence_progress</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="c1"># Solve the problem</span>
        <span class="n">lib_wrapper</span> <span class="o">=</span> <span class="n">OPTIMIZATION_LIBRARIES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">]</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">lib_wrapper</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">)</span>

        <span class="c1"># Retrieve last solution (also works for gradient-free solvers when updating on gradient)</span>
        <span class="n">x_final_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_last_norm</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_last_norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span><span class="p">(</span><span class="n">x_final_norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">x_final_norm</span><span class="p">)</span>

        <span class="c1"># Store final solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_final</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">success</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">solution</span>

        <span class="c1"># Calculate elapsed time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>

        <span class="c1"># Print report footer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_convergence_progress</span><span class="p">(</span><span class="n">x_final_norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_footer</span><span class="p">()</span>

        <span class="c1"># Save variable in physical scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_final_norm</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x_final_norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">scale_normalized_to_physical</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_final_norm</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_final</span></div>


<div class="viewcode-block" id="OptimizationSolver.fitness">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver.fitness">[docs]</a>
    <span class="k">def</span> <span class="nf">fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_norm</span><span class="p">,</span> <span class="n">called_from_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the optimization problem values at a given point x.</span>

<span class="sd">        This method queries the `fitness` method of the OptimizationProblem class to</span>
<span class="sd">        compute the objective function value and constraint values. It first checks the cache</span>
<span class="sd">        to avoid redundant evaluations. If no matching cached result exists, it proceeds to</span>
<span class="sd">        evaluate the objective function and constraints.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Vector of independent variables (i.e., degrees of freedom).</span>
<span class="sd">        called_from_grad : bool, optional</span>
<span class="sd">            Flag used to indicate if the method is called during gradient evaluation.</span>
<span class="sd">            This helps in preventing redundant increments in evaluation counts during</span>
<span class="sd">            finite-differences gradient calculations. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fitness : numpy.ndarray</span>
<span class="sd">            A 1D array containing the objective function, equality constraints, and inequality constraints at `x`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If x hasn&#39;t changed, use cached values</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tolerance_cache</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;fitness&quot;</span><span class="p">]</span>

        <span class="c1"># Increase total counter (includes finite differences)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_count_tot</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Evaluate objective function and constraints at once</span>
        <span class="n">fitness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">fitness_normalized_input</span><span class="p">(</span><span class="n">x_norm</span><span class="p">)</span>

        <span class="c1"># Does not include finite differences</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">called_from_grad</span><span class="p">:</span>
            <span class="c1"># Update cached variabled</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x_norm</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>  <span class="c1"># Needed for finite differences</span>
                    <span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="n">fitness</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;c_eq&quot;</span><span class="p">:</span> <span class="n">fitness</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span><span class="p">],</span>
                    <span class="s2">&quot;c_ineq&quot;</span><span class="p">:</span> <span class="n">fitness</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span> <span class="p">:],</span>
                    <span class="s2">&quot;fitness&quot;</span><span class="p">:</span> <span class="n">fitness</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

            <span class="c1"># Increase minor iteration counter (line search)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func_count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Update progress report</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_on</span> <span class="o">==</span> <span class="s2">&quot;function&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_print_convergence_progress</span><span class="p">(</span><span class="n">x_norm</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fitness</span></div>


<div class="viewcode-block" id="OptimizationSolver.gradient">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver.gradient">[docs]</a>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_norm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the Jacobian matrix of the optimization problem at the given point x.</span>

<span class="sd">        This method utilizes the `gradient` method of the OptimizationProblem class if implemented.</span>
<span class="sd">        If the `gradient` method is not implemented, the Jacobian is approximated using forward finite differences.</span>

<span class="sd">        To prevent redundant calculations, cached results are checked first. If a matching</span>
<span class="sd">        cached result is found, it is returned; otherwise, a fresh calculation is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Vector of independent variables (i.e., degrees of freedom).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            A 2D array representing the Jacobian matrix of the optimization problem at `x`.</span>
<span class="sd">            The Jacobian matrix includes:</span>
<span class="sd">            - Gradient of the objective function</span>
<span class="sd">            - Jacobian of equality constraints</span>
<span class="sd">            - Jacobian of inequality constraints</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If x hasn&#39;t changed, use cached values</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;x_jac&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;x_jac&quot;</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tolerance_cache</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;gradient&quot;</span><span class="p">]</span>

        <span class="c1"># Use problem gradient method if it exists</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="p">,</span> <span class="s2">&quot;gradient&quot;</span><span class="p">):</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">gradient_normalized_input</span><span class="p">(</span><span class="n">x_norm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fall back to finite differences</span>
            <span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">called_from_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">numerical_differentiation</span><span class="o">.</span><span class="n">approx_gradient</span><span class="p">(</span>
                <span class="n">fun</span><span class="p">,</span>
                <span class="n">x_norm</span><span class="p">,</span>
                <span class="n">f0</span><span class="o">=</span><span class="n">fun</span><span class="p">(</span><span class="n">x_norm</span><span class="p">),</span>
                <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">derivative_method</span><span class="p">,</span>
                <span class="n">abs_step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">derivative_abs_step</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Reshape gradient for unconstrained problems</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>

        <span class="c1"># Update cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;x_jac&quot;</span><span class="p">:</span> <span class="n">x_norm</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="s2">&quot;f_jac&quot;</span><span class="p">:</span> <span class="n">grad</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                <span class="s2">&quot;c_eq_jac&quot;</span><span class="p">:</span> <span class="n">grad</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span><span class="p">,</span> <span class="p">:],</span>
                <span class="s2">&quot;c_ineq_jac&quot;</span><span class="p">:</span> <span class="n">grad</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span> <span class="p">:,</span> <span class="p">:],</span>
                <span class="s2">&quot;gradient&quot;</span><span class="p">:</span> <span class="n">grad</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="c1"># Update progress report</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grad_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_on</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_print_convergence_progress</span><span class="p">(</span><span class="n">x_norm</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grad</span></div>


    <span class="k">def</span> <span class="nf">_handle_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">savefile</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">to_console</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unified output handler: print, log, and optionally save to a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        text : str</span>
<span class="sd">            The content to emit. Can be single or multiline.</span>
<span class="sd">        savefile : bool, optional</span>
<span class="sd">            If True, saves `text` to the given filename. Default is False.</span>
<span class="sd">        filename : str or None, optional</span>
<span class="sd">            Path to file where output should be saved. Required if savefile is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Print to logger</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">text</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="c1"># Print to screen if display is enabled and no logger used</span>
        <span class="c1"># if self.display and not self.logger:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span> <span class="ow">and</span> <span class="n">to_console</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="c1"># Save to file if requested</span>
        <span class="k">if</span> <span class="n">savefile</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Filename must be provided if savefile is True.&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a formatted header for the optimization report.</span>

<span class="sd">        This internal method is used to display a consistent header format at the</span>
<span class="sd">        beginning of the optimization process. The header includes columns for function</span>
<span class="sd">        evaluations, gradient evaluations, objective function value, constraint violations,</span>
<span class="sd">        and norm of the steps.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Define header text</span>
        <span class="n">initial_message</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot; Starting optimization process for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; Optimization algorithm employed: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="s1">&#39;Grad-eval&#39;</span><span class="si">:</span><span class="s2">&gt;13</span><span class="si">}{</span><span class="s1">&#39;Func-eval&#39;</span><span class="si">:</span><span class="s2">&gt;13</span><span class="si">}{</span><span class="s1">&#39;Func-value&#39;</span><span class="si">:</span><span class="s2">&gt;16</span><span class="si">}{</span><span class="s1">&#39;Infeasibility&#39;</span><span class="si">:</span><span class="s2">&gt;18</span><span class="si">}{</span><span class="s1">&#39;Norm of step&#39;</span><span class="si">:</span><span class="s2">&gt;18</span><span class="si">}{</span><span class="s1">&#39;Optimality&#39;</span><span class="si">:</span><span class="s2">&gt;18</span><span class="si">}</span><span class="s2"> &quot;</span>
        <span class="n">separator</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
        <span class="n">lines_to_output</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">separator</span><span class="p">,</span>
            <span class="n">initial_message</span><span class="p">,</span>
            <span class="n">separator</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span>
            <span class="n">separator</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="c1"># Print or log content</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines_to_output</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_output</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">to_console</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Store text in memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_report</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lines_to_output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_print_convergence_progress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print the current optimization status and update convergence history.</span>

<span class="sd">        This method captures and prints the following metrics:</span>
<span class="sd">        - Number of gradient evaluations</span>
<span class="sd">        - Number of function evaluations</span>
<span class="sd">        - Objective function value</span>
<span class="sd">        - Maximum constraint violation</span>
<span class="sd">        - Norm of the update step</span>

<span class="sd">        The method also updates the stored convergence history for potential future analysis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            The current solution (i.e., vector of independent variable values)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The norm of the update step is calculated as the two-norm of the difference</span>
<span class="sd">        between the current and the last independent variables. Constraints violation is</span>
<span class="sd">        computed as the infinity norm of the active constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure fitness is computed at least once before printing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;fitness&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Compute the norm of the last step</span>
        <span class="n">norm_step</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_last_norm</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_last_norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_last_norm</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Compute the maximun constraint violation</span>
        <span class="n">c_eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;c_eq&quot;</span><span class="p">]</span>
        <span class="n">c_ineq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;c_ineq&quot;</span><span class="p">]</span>
        <span class="n">violation_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">c_eq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">c_ineq</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="n">violation_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">violation_all</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">violation_all</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="n">kkt_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_kkt_conditions</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">50</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tolerance&quot;</span><span class="p">])</span>
        <span class="n">optimality</span> <span class="o">=</span> <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;first_order_optimality&quot;</span><span class="p">]</span>

        <span class="c1"># Store convergence status</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_history</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_last_norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_history</span><span class="p">[</span><span class="s2">&quot;grad_count&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grad_count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_history</span><span class="p">[</span><span class="s2">&quot;func_count&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_history</span><span class="p">[</span><span class="s2">&quot;func_count_total&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_count_tot</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_history</span><span class="p">[</span><span class="s2">&quot;objective_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_history</span><span class="p">[</span><span class="s2">&quot;constraint_violation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">violation_max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_history</span><span class="p">[</span><span class="s2">&quot;norm_step&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm_step</span><span class="p">)</span>

        <span class="c1"># Current convergence message</span>
        <span class="n">status</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grad_count</span><span class="si">:</span><span class="s2">13d</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">func_count</span><span class="si">:</span><span class="s2">13d</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">+16.3e</span><span class="si">}{</span><span class="n">violation_max</span><span class="si">:</span><span class="s2">+18.3e</span><span class="si">}{</span><span class="n">norm_step</span><span class="si">:</span><span class="s2">+18.3e</span><span class="si">}{</span><span class="n">optimality</span><span class="si">:</span><span class="s2">+18.3e</span><span class="si">}</span><span class="s2"> &quot;</span>
        <span class="c1"># status = f&quot; {self.grad_count:13d}{self.func_count:13d}{self.cache[&#39;f&#39;]:+16.3e}{violation_max:+18.3e}{norm_step:+18.3e} &quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle_output</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">to_console</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Store text in memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_report</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>

        <span class="c1"># Refresh the plot with current values</span>
        <span class="c1"># TODO for some reason convergence plot and thermodynamic cycle are not being plotten when options set to true</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_plot_convergence_callback</span><span class="p">([],</span> <span class="p">[])</span>

        <span class="c1"># Evaluate callback functions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_functions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callback_function_call_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_functions</span><span class="p">:</span>
                <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_function_call_count</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_footer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a formatted footer for the optimization report.</span>

<span class="sd">        This method displays the final optimization result, including the</span>
<span class="sd">        exit message, success status, objective function value, and decision variables.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The footer&#39;s structure is intended to match the header&#39;s style,</span>
<span class="sd">        providing a consistent look to the optimization report.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define footer text</span>
        <span class="n">separator</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
        <span class="n">exit_message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; Exit message: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">success_status</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; Success: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">success</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">time_message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; Solution time: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">elapsed_time</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> seconds&quot;</span>
        <span class="n">lines_to_output</span> <span class="o">=</span> <span class="p">[</span><span class="n">separator</span><span class="p">,</span> <span class="n">success_status</span><span class="p">,</span> <span class="n">exit_message</span><span class="p">,</span> <span class="n">time_message</span><span class="p">]</span>
        <span class="n">lines_to_output</span> <span class="o">+=</span> <span class="p">[</span><span class="n">separator</span><span class="p">]</span>

        <span class="c1"># Print or log content</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines_to_output</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_output</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">to_console</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Store text in memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_report</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lines_to_output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_plot_convergence_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">initialize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showfig</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback function to dynamically update the convergence progress plot.</span>

<span class="sd">        This method initializes a matplotlib plot on the first iteration and updates</span>
<span class="sd">        the data for each subsequent iteration. The plot showcases the evolution of</span>
<span class="sd">        the objective function and the constraint violation with respect to the</span>
<span class="sd">        number of iterations.</span>

<span class="sd">        The left y-axis depicts the objective function values, while the right y-axis</span>
<span class="sd">        showcases the constraint violation values. The x-axis represents the number</span>
<span class="sd">        of iterations. Both lines are updated and redrawn dynamically as iterations progress.</span>

<span class="sd">        Note:</span>
<span class="sd">            This is an internal method, meant to be called within the optimization process.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize figure before first iteration</span>
        <span class="k">if</span> <span class="n">initialize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax_1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_line_1</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax_1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="p">[],</span> <span class="p">[],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#0072BD&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Objective function&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax_1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Number of iterations&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax_1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Objective function&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax_1</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_scale_objective</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax_1</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span>
                <span class="n">MaxNLocator</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># Integer ticks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax_1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_ineq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax_1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax_2</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax_2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Constraint violation&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax_2</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_scale_constraints</span><span class="p">)</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_line_2</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax_2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="p">[],</span> <span class="p">[],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#D95319&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Constraint violation&quot;</span>
                <span class="p">)</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_line_1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_line_2</span><span class="p">]</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax_2</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax_1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Update plot data with current values</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convergence_history</span><span class="p">[</span><span class="s2">&quot;func_count&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_on</span> <span class="o">==</span> <span class="s2">&quot;function&quot;</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">convergence_history</span><span class="p">[</span><span class="s2">&quot;grad_count&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">objective_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convergence_history</span><span class="p">[</span><span class="s2">&quot;objective_value&quot;</span><span class="p">]</span>
        <span class="n">constraint_violation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convergence_history</span><span class="p">[</span><span class="s2">&quot;constraint_violation&quot;</span><span class="p">]</span>

        <span class="c1"># Iterate through the objective_function values to create the new series</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_improvement_only</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">objective_function</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">objective_function</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">objective_function</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">objective_function</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">objective_function</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Update graphic objects data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_line_1</span><span class="o">.</span><span class="n">set_xdata</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_line_1</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">objective_function</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_ineq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obj_line_2</span><span class="o">.</span><span class="n">set_xdata</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obj_line_2</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">constraint_violation</span><span class="p">)</span>

        <span class="c1"># Adjust the plot limits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax_1</span><span class="o">.</span><span class="n">relim</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax_1</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_ineq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax_2</span><span class="o">.</span><span class="n">relim</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax_2</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="c1"># Redraw the plot</span>
        <span class="k">if</span> <span class="n">showfig</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># small pause to allow for update</span>


<div class="viewcode-block" id="OptimizationSolver.plot_convergence_history">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver.plot_convergence_history">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_convergence_history</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">savefile</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;output&quot;</span><span class="p">,</span>
        <span class="n">showfig</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the convergence history of the problem.</span>

<span class="sd">        This method plots the optimization progress against the number of iterations:</span>
<span class="sd">            - Objective function value (left y-axis)</span>
<span class="sd">            - Maximum constraint violation (right y-axis)</span>

<span class="sd">        The constraint violation is only displayed if the problem has nonlinear constraints</span>

<span class="sd">        This method should be called only after the optimization problem has been solved, as it relies on data generated by the solving process.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        savefile : bool, optional</span>
<span class="sd">            If True, the plot is saved to a file instead of being displayed. Default is False.</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            The name of the file to save the plot to. If not specified, the filename is automatically generated</span>
<span class="sd">            using the problem name and the start datetime. The file extension is not required.</span>
<span class="sd">        output_dir : str, optional</span>
<span class="sd">            The directory where the plot file will be saved if savefile is True. Default is &quot;output&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.figure.Figure</span>
<span class="sd">            The Matplotlib figure object for the plot. This can be used for further customization or display.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If this method is called before the problem has been solved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_final</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This method can only be used after invoking the &#39;solve()&#39; method.&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize and optionally show plot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_convergence_callback</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">initialize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showfig</span><span class="o">=</span><span class="n">showfig</span><span class="p">)</span>

        <span class="c1"># Save if requested</span>
        <span class="k">if</span> <span class="n">savefile</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">basename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">start_datetime</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;convergence_history_</span><span class="si">{</span><span class="n">basename</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">savefig_in_formats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">formats</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;.png&quot;</span><span class="p">,</span> <span class="s2">&quot;.svg&quot;</span><span class="p">])</span>

        <span class="c1"># Close the figure if it should not be displayed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">showfig</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span></div>

    

<div class="viewcode-block" id="OptimizationSolver.print_convergence_history">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver.print_convergence_history">[docs]</a>
    <span class="k">def</span> <span class="nf">print_convergence_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">savefile</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;output&quot;</span><span class="p">,</span> <span class="n">to_console</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print or save the convergence history of the optimization process.</span>

<span class="sd">        This function prints (or saves) a the report of the optimization convergence progress.</span>
<span class="sd">        It includes information collected at each iteration, including:</span>

<span class="sd">        - Number of gradient evaluations</span>
<span class="sd">        - Number of function evaluations</span>
<span class="sd">        - Objective function value</span>
<span class="sd">        - Maximum constraint violation</span>
<span class="sd">        - Two-norm of the update step</span>

<span class="sd">        It also includes a summary at the end of the run with:</span>

<span class="sd">        - Exit message</span>
<span class="sd">        - Success flag</span>
<span class="sd">        - Total solution time (in seconds)</span>

<span class="sd">        .. note::</span>
<span class="sd">            This method must be called **after** `solve()` has been executed. Otherwise, the convergence</span>
<span class="sd">            report is unavailable and a `ValueError` is raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        savefile : bool, optional</span>
<span class="sd">            If True, the report is saved to a file. Otherwise, it is printed to the screen. Default is False.</span>

<span class="sd">        filename : str or None, optional</span>
<span class="sd">            The name of the file to save the report to. If None, a default name is generated based on the</span>
<span class="sd">            problem class name and the optimization start datetime.</span>

<span class="sd">        output_dir : str, optional</span>
<span class="sd">            Directory where the report file is saved if `savefile=True`. Default is &quot;output&quot;.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the method is called before the optimization problem has been solved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_final</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This method can only be used after invoking the &#39;solve()&#39; method.&quot;</span><span class="p">)</span>

        <span class="c1"># Join convergence history lines</span>
        <span class="n">full_text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convergence_report</span><span class="p">)</span>

        <span class="c1"># Decide filename if saving to disk</span>
        <span class="k">if</span> <span class="n">savefile</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">default</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">start_datetime</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;convergence_history_</span><span class="si">{</span><span class="n">default</span><span class="si">}</span><span class="s2">.txt&quot;</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Output the report (either print or save to file)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle_output</span><span class="p">(</span><span class="n">full_text</span><span class="p">,</span> <span class="n">savefile</span><span class="o">=</span><span class="n">savefile</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filepath</span><span class="p">,</span> <span class="n">to_console</span><span class="o">=</span><span class="n">to_console</span><span class="p">)</span></div>



<div class="viewcode-block" id="OptimizationSolver.print_optimization_report">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver.print_optimization_report">[docs]</a>
    <span class="k">def</span> <span class="nf">print_optimization_report</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">include_design_variables</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">include_constraints</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">include_kkt_conditions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">include_multipliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">savefile</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;output&quot;</span><span class="p">,</span>
        <span class="n">to_console</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate and print or save a complete optimization report with customizable content.</span>

<span class="sd">        This method assembles a detailed summary of the optimization process and results,</span>
<span class="sd">        allowing fine-grained control over which components to include. It supports</span>
<span class="sd">        outputting the report to the console or saving it to a file.</span>

<span class="sd">        The report may include the following sections:</span>
<span class="sd">        - Convergence history: number of function and gradient evaluations, objective function value, maximum constraint violation, and step norm. The report also includes The method provides a detailed report on an exit message, success status, and execution time</span>
<span class="sd">        - Number of function evaluations</span>
<span class="sd">        - Number of gradient evaluations</span>
<span class="sd">        - Objective function value</span>
<span class="sd">        - Maximum constraint violation</span>
<span class="sd">        - Two-norm of the update step</span>

<span class="sd">    </span>
<span class="sd">    Objective value, constraint violation, and step norm over iterations.</span>
<span class="sd">        - Design variables: Final values, shown in physical units and (if applicable) normalized space.</span>
<span class="sd">        - Constraints: Numerical values and satisfaction status of all constraints.</span>
<span class="sd">        - KKT conditions: Checks of the Karush-Kuhn-Tucker optimality conditions.</span>
<span class="sd">        - Lagrange multipliers: Values of multipliers for equality, inequality, and bound constraints.</span>

<span class="sd">        This method is intended to be called after the `solve()` method has been completed.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_convergence_history : bool</span>
<span class="sd">        include_design_variables_normalized : bool</span>
<span class="sd">        include_design_variables_physical : bool</span>
<span class="sd">        include_constraints : bool</span>
<span class="sd">        include_kkt : bool</span>
<span class="sd">        include_multipliers : bool</span>
<span class="sd">        savefile : bool</span>
<span class="sd">        filename : str or None</span>
<span class="sd">        tol : float or None  (tolerance for constraints/KKT)</span>
<span class="sd">        output_dir : str      (directory for saving file)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Define the vector of independent variables</span>
        <span class="n">x_phys</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_final</span>
        <span class="n">x_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">scale_physical_to_normalized</span><span class="p">(</span><span class="n">x_phys</span><span class="p">)</span>

        <span class="c1"># Use a loose tolerance if not given as argument</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tolerance&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tol</span>

        <span class="c1"># Collect each section’s text and soin into a single string</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">include_kkt_conditions</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_kkt_optimality_report</span><span class="p">(</span><span class="n">x_norm</span><span class="p">,</span> <span class="n">tol</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">include_design_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">problem_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_variables_report</span><span class="p">(</span><span class="n">x_norm</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_variables_report</span><span class="p">(</span><span class="n">x_norm</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_variables_report</span><span class="p">(</span><span class="n">x_phys</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>    
        <span class="k">if</span> <span class="n">include_constraints</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_constraint_report</span><span class="p">(</span><span class="n">x_norm</span><span class="p">,</span> <span class="n">tol</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">include_multipliers</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_lagrange_multipliers_report</span><span class="p">(</span><span class="n">x_norm</span><span class="p">,</span> <span class="n">tol</span><span class="p">))</span>
        <span class="n">full_text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="c1"># Decide on filename if saving</span>
        <span class="k">if</span> <span class="n">savefile</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;optimization_report_</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">start_datetime</span><span class="si">}</span><span class="s2">.txt&quot;</span>
                <span class="p">)</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># 5) emit once to console, logger, or file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle_output</span><span class="p">(</span><span class="n">full_text</span><span class="p">,</span> <span class="n">savefile</span><span class="o">=</span><span class="n">savefile</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filepath</span><span class="p">,</span> <span class="n">to_console</span><span class="o">=</span><span class="n">to_console</span><span class="p">)</span></div>




    <span class="c1"># def make_optimization_report(self, x_phys, tol=1e-6):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Print or save a complete optimization report, including variables and constraints.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     report = []</span>
    <span class="c1">#     report.append(self.make_variables_report(x_phys, normalized=True))</span>
    <span class="c1">#     report.append(self.make_variables_report(x_phys, normalized=False))</span>
    <span class="c1">#     report.append(self.make_constraint_report(x_phys, tol=tol))</span>
    <span class="c1">#     return &quot;\n&quot;.join(report)</span>

<div class="viewcode-block" id="OptimizationSolver.make_variables_report">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver.make_variables_report">[docs]</a>
    <span class="k">def</span> <span class="nf">make_variables_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_norm</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate design variable report as a string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_norm : array-like</span>
<span class="sd">            Normalized design variables (input to the solver).</span>
<span class="sd">        normalized : bool, optional</span>
<span class="sd">            Whether to report in normalized or physical values. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Formatted string report.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x_norm</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">x_norm</span>
            <span class="n">lb_raw</span><span class="p">,</span> <span class="n">ub_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_bounds_normalized</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">x_norm</span>
            <span class="n">lb_raw</span><span class="p">,</span> <span class="n">ub_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">()</span>

        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">variable_names</span> <span class="ow">or</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;design_variable_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">scale_type</span> <span class="o">=</span> <span class="s2">&quot;normalized&quot;</span> <span class="k">if</span> <span class="n">normalized</span> <span class="k">else</span> <span class="s2">&quot;physical&quot;</span>
        <span class="n">max_name_width</span> <span class="o">=</span> <span class="mi">38</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span><span class="p">)</span>
        <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39; Optimization variables report (&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">scale_type</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39; values)&#39;</span><span class="si">:</span><span class="s2">&lt;80</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="s1">&#39;Variable name&#39;</span><span class="si">:</span><span class="s2">&lt;39</span><span class="si">}{</span><span class="s1">&#39;Lower&#39;</span><span class="si">:</span><span class="s2">&gt;13</span><span class="si">}{</span><span class="s1">&#39;Value&#39;</span><span class="si">:</span><span class="s2">&gt;13</span><span class="si">}{</span><span class="s1">&#39;Upper&#39;</span><span class="si">:</span><span class="s2">&gt;13</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">ub</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">lb_raw</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">ub_raw</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_name_width</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;...&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">max_name_width</span> <span class="o">-</span> <span class="mi">3</span><span class="p">):]</span>

            <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">key</span><span class="si">:</span><span class="s2">&lt;39</span><span class="si">}{</span><span class="n">lb</span><span class="si">:</span><span class="s2">&gt;13.4f</span><span class="si">}{</span><span class="n">val</span><span class="si">:</span><span class="s2">&gt;13.4f</span><span class="si">}{</span><span class="n">ub</span><span class="si">:</span><span class="s2">&gt;13.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">key</span><span class="si">:</span><span class="s2">&lt;39</span><span class="si">}{</span><span class="n">lb</span><span class="si">:</span><span class="s2">&gt;13.3e</span><span class="si">}{</span><span class="n">val</span><span class="si">:</span><span class="s2">&gt;13.3e</span><span class="si">}{</span><span class="n">ub</span><span class="si">:</span><span class="s2">&gt;13.3e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>


<div class="viewcode-block" id="OptimizationSolver.get_constraint_data">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver.get_constraint_data">[docs]</a>
    <span class="k">def</span> <span class="nf">get_constraint_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_norm</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return a list of dicts with keys:</span>
<span class="sd">          name, type (&#39;=&#39;, &#39;&lt;&#39;), target, value, satisfied</span>
<span class="sd">        for all equality and inequality constraints.</span>
<span class="sd">        If self.constraint_data exists, validate and return it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use cached constraint data if available and valid</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="p">,</span> <span class="s2">&quot;constraint_data&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">constraint_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">constraint_data</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected self.constraint_data to be a list of dicts&quot;</span><span class="p">)</span>
            <span class="n">required</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="s2">&quot;satisfied&quot;</span><span class="p">}</span>
            <span class="n">allowed</span> <span class="o">=</span> <span class="n">required</span> <span class="o">|</span> <span class="p">{</span><span class="s2">&quot;normalized_mismatch&quot;</span><span class="p">,</span> <span class="s2">&quot;mismatch&quot;</span><span class="p">,</span> <span class="s2">&quot;normalize&quot;</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">constraint_data</span><span class="p">:</span>
                <span class="n">validate_keys</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">required</span><span class="p">,</span> <span class="n">allowed</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">constraint_data</span>

        <span class="c1"># Otherwise evaluate constraints from scratch</span>
        <span class="n">x_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x_norm</span><span class="p">)</span>
        <span class="n">fitness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span><span class="p">(</span><span class="n">x_norm</span><span class="p">)</span>  <span class="c1"># Uses cache if available</span>
        <span class="n">c_eq</span> <span class="o">=</span> <span class="n">fitness</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span><span class="p">]</span>
        <span class="n">c_ineq</span> <span class="o">=</span> <span class="n">fitness</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span><span class="p">:]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Equality constraints</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c_eq</span><span class="p">):</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;equality_constraint_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                    <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">val</span><span class="p">,</span>
                    <span class="s2">&quot;satisfied&quot;</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="c1"># Inequality constraints</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c_ineq</span><span class="p">):</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;inequality_constraint_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                    <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">val</span><span class="p">,</span>
                    <span class="s2">&quot;satisfied&quot;</span><span class="p">:</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>



<div class="viewcode-block" id="OptimizationSolver.evaluate_kkt_conditions">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver.evaluate_kkt_conditions">[docs]</a>
    <span class="k">def</span> <span class="nf">evaluate_kkt_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_norm</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the raw quantities required for KKT condition checks.</span>

<span class="sd">        This method performs all necessary calculations to evaluate:</span>
<span class="sd">            - Lagrangian gradient</span>
<span class="sd">            - Constraint violations (equality and inequality)</span>
<span class="sd">            - Lagrange multipliers for active constraints</span>
<span class="sd">            - Complementary slackness products</span>

<span class="sd">        It does not apply any tolerance threshold; that is handled separately.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary containing raw values needed to assess the KKT conditions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Calculate problem values and gradients (possibily retrieving cached values)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span><span class="p">(</span><span class="n">x_norm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">x_norm</span><span class="p">)</span>

        <span class="c1"># Retrieve gradients and Jacobians from cache</span>
        <span class="n">f_jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;f_jac&quot;</span><span class="p">]</span>
        <span class="n">c_eq_jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;c_eq_jac&quot;</span><span class="p">]</span>
        <span class="n">c_ineq_jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;c_ineq_jac&quot;</span><span class="p">]</span>
        <span class="n">c_eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;c_eq&quot;</span><span class="p">]</span>
        <span class="n">c_ineq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s2">&quot;c_ineq&quot;</span><span class="p">]</span>

        <span class="c1"># Re-cast bounds as inequality constraints</span>
        <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_bounds_normalized</span><span class="p">()</span>
        <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
        <span class="n">c_lb</span><span class="p">,</span> <span class="n">c_ub</span> <span class="o">=</span> <span class="n">lb</span> <span class="o">-</span> <span class="n">x_norm</span><span class="p">,</span> <span class="n">x_norm</span> <span class="o">-</span> <span class="n">ub</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">x_norm</span><span class="o">.</span><span class="n">size</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">jac_lb</span> <span class="o">=</span> <span class="o">-</span><span class="n">I</span>  <span class="c1"># ∇(lb_i - x_i) = -e_i</span>
        <span class="n">jac_ub</span> <span class="o">=</span> <span class="o">+</span><span class="n">I</span>  <span class="c1"># ∇(x_i - ub_i) = +e_i</span>
        <span class="n">c_ineq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">c_ineq</span><span class="p">,</span> <span class="n">c_lb</span><span class="p">,</span> <span class="n">c_ub</span><span class="p">])</span>
        <span class="n">c_ineq_jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">c_ineq_jac</span><span class="p">,</span> <span class="n">jac_lb</span><span class="p">,</span> <span class="n">jac_ub</span><span class="p">])</span>

        <span class="c1"># Identify active inequality constraints (c_i(x) ≈ 0)</span>
        <span class="n">idx_active_ineq</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c_ineq</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">]</span>

        <span class="c1"># Build full constraint Jacobian for active constraints</span>
        <span class="n">c_jac_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c_jac_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_eq_jac</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx_active_ineq</span><span class="p">:</span>
            <span class="n">c_jac_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_ineq_jac</span><span class="p">[</span><span class="n">idx_active_ineq</span><span class="p">])</span>

        <span class="c1"># Solve stationarity condition: grad(f) + J^T * mu = 0</span>
        <span class="k">if</span> <span class="n">c_jac_blocks</span><span class="p">:</span>
            <span class="n">c_jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">c_jac_blocks</span><span class="p">)</span>
            <span class="n">mu_vec</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">c_jac</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">-</span><span class="n">f_jac</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mu_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">mu_eq</span> <span class="o">=</span> <span class="n">mu_vec</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">mu_ineq</span> <span class="o">=</span> <span class="n">mu_vec</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span> <span class="p">:]</span> <span class="k">if</span> <span class="n">idx_active_ineq</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># Compute gradient of Lagrangian</span>
        <span class="n">lagrangian_gradient</span> <span class="o">=</span> <span class="n">f_jac</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lagrangian_gradient</span> <span class="o">+=</span> <span class="n">c_eq_jac</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">mu_eq</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx_active_ineq</span><span class="p">,</span> <span class="n">mu_ineq</span><span class="p">):</span>
            <span class="n">lagrangian_gradient</span> <span class="o">+=</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">c_ineq_jac</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Compute slackness products mu_i * h_i(x)</span>
        <span class="n">slack_products</span> <span class="o">=</span> <span class="p">[</span><span class="n">mu</span> <span class="o">*</span> <span class="n">c_ineq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx_active_ineq</span><span class="p">,</span> <span class="n">mu_ineq</span><span class="p">)]</span>

        <span class="c1"># Save in dictionary</span>
        <span class="n">kkt_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;lagrangian_gradient&quot;</span><span class="p">:</span> <span class="n">lagrangian_gradient</span><span class="p">,</span>
            <span class="s2">&quot;equality_violation&quot;</span><span class="p">:</span> <span class="n">c_eq</span><span class="p">,</span>
            <span class="s2">&quot;inequality_violation&quot;</span><span class="p">:</span> <span class="n">c_ineq</span><span class="p">,</span>
            <span class="s2">&quot;multipliers_eq&quot;</span><span class="p">:</span> <span class="n">mu_eq</span><span class="p">,</span>
            <span class="s2">&quot;multipliers_ineq&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">mu</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx_active_ineq</span><span class="p">,</span> <span class="n">mu_ineq</span><span class="p">)},</span>
            <span class="s2">&quot;slack_products&quot;</span><span class="p">:</span> <span class="n">slack_products</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># ------------------------------------------ #</span>
        <span class="c1"># ---------- Check KKT conditions ---------- #</span>
        <span class="c1"># ------------------------------------------ #</span>

        <span class="c1"># 1. First-order optimality (||∇L|| ≈ 0)</span>
        <span class="n">grad_L</span> <span class="o">=</span> <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;lagrangian_gradient&quot;</span><span class="p">]</span>
        <span class="n">first_order_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">grad_L</span><span class="p">)</span>
        <span class="n">first_order_ok</span> <span class="o">=</span> <span class="n">first_order_val</span> <span class="o">&lt;=</span> <span class="n">tol</span>

        <span class="c1"># 2. Equality feasibility (|c_eq_i| &lt;= tol)</span>
        <span class="n">c_eq</span> <span class="o">=</span> <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;equality_violation&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_eq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">feasibility_eq_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c_eq</span><span class="p">))</span>
            <span class="n">feasibility_eq_ok</span> <span class="o">=</span> <span class="n">feasibility_eq_val</span> <span class="o">&lt;=</span> <span class="n">tol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">feasibility_eq_val</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">feasibility_eq_ok</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># 3. Inequality feasibility (c_ineq_i &lt;= 0)</span>
        <span class="n">c_ineq</span> <span class="o">=</span> <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;inequality_violation&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_ineq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">feasibility_ineq_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">c_ineq</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
            <span class="n">feasibility_ineq_ok</span> <span class="o">=</span> <span class="n">feasibility_ineq_val</span> <span class="o">&lt;=</span> <span class="n">tol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">feasibility_ineq_val</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">feasibility_ineq_ok</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># 4. Dual feasibility (mu_ineq_i &gt;= 0)</span>
        <span class="n">mu_ineq_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;multipliers_ineq&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">mu_ineq_vals</span><span class="p">:</span>
            <span class="n">feasibility_dual_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mu_ineq_vals</span><span class="p">)</span>
            <span class="n">feasibility_dual_ok</span> <span class="o">=</span> <span class="n">feasibility_dual_val</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">feasibility_dual_val</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">feasibility_dual_ok</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># 5. Complementary slackness (mu_ineq_i * c_ineq_i ≈ 0)</span>
        <span class="n">slack_products</span> <span class="o">=</span> <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;slack_products&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">slack_products</span><span class="p">:</span>
            <span class="n">complementary_slack_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">slack_products</span><span class="p">))</span>
            <span class="n">complementary_slack_ok</span> <span class="o">=</span> <span class="n">complementary_slack_val</span> <span class="o">&lt;=</span> <span class="n">tol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">complementary_slack_val</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">complementary_slack_ok</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="o">**</span><span class="n">kkt_data</span><span class="p">,</span>
            <span class="s2">&quot;first_order_optimality&quot;</span><span class="p">:</span> <span class="n">first_order_val</span><span class="p">,</span>
            <span class="s2">&quot;feasibility_equality&quot;</span><span class="p">:</span> <span class="n">feasibility_eq_val</span><span class="p">,</span>
            <span class="s2">&quot;feasibility_inequality&quot;</span><span class="p">:</span> <span class="n">feasibility_ineq_val</span><span class="p">,</span>
            <span class="s2">&quot;feasibility_dual&quot;</span><span class="p">:</span> <span class="n">feasibility_dual_val</span><span class="p">,</span>
            <span class="s2">&quot;complementary_slackness&quot;</span><span class="p">:</span> <span class="n">complementary_slack_val</span><span class="p">,</span>
            <span class="s2">&quot;first_order_optimality_ok&quot;</span><span class="p">:</span> <span class="n">first_order_ok</span><span class="p">,</span>
            <span class="s2">&quot;feasibility_equality_ok&quot;</span><span class="p">:</span> <span class="n">feasibility_eq_ok</span><span class="p">,</span>
            <span class="s2">&quot;feasibility_inequality_ok&quot;</span><span class="p">:</span> <span class="n">feasibility_ineq_ok</span><span class="p">,</span>
            <span class="s2">&quot;feasibility_dual_ok&quot;</span><span class="p">:</span> <span class="n">feasibility_dual_ok</span><span class="p">,</span>
            <span class="s2">&quot;complementary_slackness_ok&quot;</span><span class="p">:</span> <span class="n">complementary_slack_ok</span><span class="p">,</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="OptimizationSolver.make_kkt_optimality_report">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver.make_kkt_optimality_report">[docs]</a>
    <span class="k">def</span> <span class="nf">make_kkt_optimality_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_norm</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a detailed KKT condition satisfaction report (80-character width).</span>

<span class="sd">        This report includes five key KKT checks:</span>
<span class="sd">        - First order optimality:     ∥∇L(x, λ)∥ ≤ tol</span>
<span class="sd">        - Equality feasibility:       max |c_eq(x)| ≤ tol</span>
<span class="sd">        - Inequality feasibility:     max(0, c_ineq(x)) ≤ tol</span>
<span class="sd">        - Dual feasibility:           min(λ_ineq) ≥ 0</span>
<span class="sd">        - Complementary slackness:    max |λ_i * c_i| ≤ tol</span>

<span class="sd">        For each condition, the report shows:</span>
<span class="sd">        - Actual computed value</span>
<span class="sd">        - Comparison direction and target (tolerance or 0)</span>
<span class="sd">        - Satisfaction status</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_norm : array-like</span>
<span class="sd">            Normalized decision variable vector to evaluate the KKT conditions at.</span>
<span class="sd">        tol : float</span>
<span class="sd">            Numerical tolerance used for comparisons in optimality and feasibility checks.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A formatted report string summarizing KKT condition satisfaction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute KKT conditions</span>
        <span class="n">kkt_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_kkt_conditions</span><span class="p">(</span><span class="n">x_norm</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

        <span class="c1"># Build report lines</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">sep</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="s1">&#39;Karush-Kuhn-Tucker (KKT) conditions&#39;</span><span class="si">:</span><span class="s2">&lt;36</span><span class="si">}{</span><span class="s1">&#39;Value&#39;</span><span class="si">:</span><span class="s2">&gt;16</span><span class="si">}{</span><span class="s1">&#39;Target&#39;</span><span class="si">:</span><span class="s2">&gt;16</span><span class="si">}{</span><span class="s1">&#39;Ok?&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">sep</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="n">entries</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="s2">&quot;First order optimality&quot;</span><span class="p">,</span>
                <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;first_order_optimality&quot;</span><span class="p">],</span>
                <span class="sa">f</span><span class="s2">&quot;&lt; </span><span class="si">{</span><span class="n">tol</span><span class="si">:</span><span class="s2">+.3e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;first_order_optimality_ok&quot;</span><span class="p">],</span>
            <span class="p">),</span>
            <span class="p">(</span>
                <span class="s2">&quot;Equality feasibility&quot;</span><span class="p">,</span>
                <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;feasibility_equality&quot;</span><span class="p">],</span>
                <span class="sa">f</span><span class="s2">&quot;&lt; </span><span class="si">{</span><span class="n">tol</span><span class="si">:</span><span class="s2">+.3e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;feasibility_equality_ok&quot;</span><span class="p">],</span>
            <span class="p">),</span>
            <span class="p">(</span>
                <span class="s2">&quot;Inequality feasibility&quot;</span><span class="p">,</span>
                <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;feasibility_inequality&quot;</span><span class="p">],</span>
                <span class="sa">f</span><span class="s2">&quot;&lt; </span><span class="si">{</span><span class="n">tol</span><span class="si">:</span><span class="s2">+.3e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;feasibility_inequality_ok&quot;</span><span class="p">],</span>
            <span class="p">),</span>
            <span class="p">(</span>
                <span class="s2">&quot;Dual feasibility&quot;</span><span class="p">,</span>
                <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;feasibility_dual&quot;</span><span class="p">],</span>
                <span class="sa">f</span><span class="s2">&quot;&gt; </span><span class="si">{</span><span class="o">-</span><span class="n">tol</span><span class="si">:</span><span class="s2">+.3e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;feasibility_dual_ok&quot;</span><span class="p">],</span>
            <span class="p">),</span>
            <span class="p">(</span>
                <span class="s2">&quot;Complementary slackness&quot;</span><span class="p">,</span>
                <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;complementary_slackness&quot;</span><span class="p">],</span>
                <span class="sa">f</span><span class="s2">&quot;&lt; </span><span class="si">{</span><span class="n">tol</span><span class="si">:</span><span class="s2">+.3e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;complementary_slackness_ok&quot;</span><span class="p">],</span>
            <span class="p">),</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">ok</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;yes&quot;</span> <span class="k">if</span> <span class="n">ok</span> <span class="k">else</span> <span class="s2">&quot; no&quot;</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="s2">&lt;36</span><span class="si">}{</span><span class="n">val</span><span class="si">:</span><span class="s2">&gt;+16.3e</span><span class="si">}{</span><span class="n">target</span><span class="si">:</span><span class="s2">&gt;16</span><span class="si">}{</span><span class="n">status</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

    

    <span class="c1"># def make_constraint_report(self, x_norm, tol):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Generate a compact constraint report that includes:</span>
    <span class="c1">#     - Constraint value and target</span>
    <span class="c1">#     - Satisfaction status</span>
    <span class="c1">#     - Lagrange multiplier (if active), otherwise &#39;inactive&#39;</span>

    <span class="c1">#     This merges value and multiplier reports for better readability.</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     x_norm : array-like</span>
    <span class="c1">#         Normalized design variable vector.</span>
    <span class="c1">#     tol : float</span>
    <span class="c1">#         Tolerance used for satisfaction and KKT activeness checks.</span>

    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     str</span>
    <span class="c1">#         A formatted string with the constraint summary.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     max_name_width = 35</span>
    <span class="c1">#     constraint_data = self.get_constraint_data(x_norm, tol)</span>
    <span class="c1">#     kkt_data = self.evaluate_kkt_conditions(x_norm, tol)</span>
    <span class="c1">#     active_multipliers = kkt_data[&quot;multipliers_ineq&quot;]</span>
    <span class="c1">#     multipliers_eq = kkt_data[&quot;multipliers_eq&quot;]</span>

    <span class="c1">#     sep = &quot;-&quot; * 80</span>
    <span class="c1">#     lines = [</span>
    <span class="c1">#         &quot;&quot;,</span>
    <span class="c1">#         sep,</span>
    <span class="c1">#         &quot; Constraint summary report&quot;,</span>
    <span class="c1">#         sep,</span>
    <span class="c1">#         f&quot; {&#39;Constraint name&#39;:&lt;{max_name_width}}{&#39;Value&#39;:&gt;12}{&#39;Target&#39;:&gt;13}{&#39;Ok?&#39;:&gt;6}{&#39;Multiplier&#39;:&gt;12}&quot;,</span>
    <span class="c1">#         sep,</span>
    <span class="c1">#     ]</span>

    <span class="c1">#     eq_count = 0</span>
    <span class="c1">#     ineq_count = 0</span>
    <span class="c1">#     var_names = self.problem.variable_names</span>
    <span class="c1">#     n_vars = len(var_names)</span>
    <span class="c1">#     n_ineq = self.problem.get_nic()</span>

    <span class="c1">#     for i, entry in enumerate(constraint_data):</span>
    <span class="c1">#         name = entry.get(&quot;name&quot;, &quot;&quot;)</span>
    <span class="c1">#         ctype = entry.get(&quot;type&quot;, &quot;&quot;)</span>
    <span class="c1">#         value = entry.get(&quot;value&quot;, 0.0)</span>
    <span class="c1">#         target = entry.get(&quot;target&quot;, 0.0)</span>
    <span class="c1">#         satisfied = &quot;yes&quot; if entry.get(&quot;satisfied&quot;, False) else &quot; no&quot;</span>

    <span class="c1">#         if len(name) &gt; max_name_width:</span>
    <span class="c1">#             name = &quot;...&quot; + name[-(max_name_width - 3):]</span>

    <span class="c1">#         # Determine the target symbol</span>
    <span class="c1">#         symbol = &quot;=&quot; if ctype == &quot;=&quot; else &quot;&lt;&quot;</span>
    <span class="c1">#         target_str = f&quot;{symbol} {target:+.3e}&quot;</span>
    <span class="c1">#         value_str = f&quot;{value:+.3e}&quot;</span>

    <span class="c1">#         # Multiplier</span>
    <span class="c1">#         if ctype == &quot;=&quot;:</span>
    <span class="c1">#             multiplier = f&quot;{multipliers_eq[eq_count]:+.3e}&quot;</span>
    <span class="c1">#             eq_count += 1</span>
    <span class="c1">#         elif ctype == &quot;&lt;&quot;:</span>
    <span class="c1">#             # Inequality constraint or bounds</span>
    <span class="c1">#             if ineq_count in active_multipliers:</span>
    <span class="c1">#                 multiplier = f&quot;{active_multipliers[ineq_count]:+.3e}&quot;</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 multiplier = &quot;inactive&quot;</span>
    <span class="c1">#             ineq_count += 1</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             multiplier = &quot;---&quot;</span>

    <span class="c1">#         lines.append(f&quot; {name:&lt;{max_name_width}}{value_str:&gt;12}{target_str:&gt;13}{satisfied:&gt;6}{multiplier:&gt;12}&quot;)</span>

    <span class="c1">#     lines.append(sep)</span>
    <span class="c1">#     return &quot;\n&quot;.join(lines)</span>


    <span class="c1"># def make_constraint_report(self, x_norm, tol):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Generate a compact constraint report that includes:</span>
    <span class="c1">#     - Constraint value and target</span>
    <span class="c1">#     - Satisfaction status</span>
    <span class="c1">#     - Lagrange multiplier (if active), otherwise &#39;inactive&#39;</span>

    <span class="c1">#     Supports equality, less-than, and greater-than constraints, including bounds.</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     x_norm : array-like</span>
    <span class="c1">#         Normalized design variable vector.</span>
    <span class="c1">#     tol : float</span>
    <span class="c1">#         Tolerance used for constraint satisfaction and activeness checks.</span>

    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     str</span>
    <span class="c1">#         A formatted string with the constraint summary.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     max_name_width = 35</span>
    <span class="c1">#     var_names = self.problem.variable_names</span>
    <span class="c1">#     n_vars = len(var_names)</span>

    <span class="c1">#     constraint_data = self.get_constraint_data(x_norm, tol)</span>
    <span class="c1">#     kkt_data = self.evaluate_kkt_conditions(x_norm, tol)</span>
    <span class="c1">#     active_multipliers = kkt_data[&quot;multipliers_ineq&quot;]</span>
    <span class="c1">#     multipliers_eq = kkt_data[&quot;multipliers_eq&quot;]</span>

    <span class="c1">#     # Append bound constraints with natural inequality direction</span>
    <span class="c1">#     lb, ub = self.problem.get_bounds_normalized()</span>
    <span class="c1">#     bounds_lower, bounds_upper = [], []</span>
    <span class="c1">#     for i, (name, xi, lb_i, ub_i) in enumerate(zip(var_names, x_norm, lb, ub)):</span>
    <span class="c1">#         if lb_i is not None:</span>
    <span class="c1">#             bounds_lower.append({</span>
    <span class="c1">#                 &quot;name&quot;: name,</span>
    <span class="c1">#                 &quot;type&quot;: &quot;&gt;&quot;,</span>
    <span class="c1">#                 &quot;value&quot;: xi,</span>
    <span class="c1">#                 &quot;target&quot;: lb_i,</span>
    <span class="c1">#                 &quot;satisfied&quot;: (xi - lb_i &gt;= -tol)  # xi ≥ lb_i</span>
    <span class="c1">#             })</span>
    <span class="c1">#         if ub_i is not None:</span>
    <span class="c1">#             bounds_upper.append({</span>
    <span class="c1">#                 &quot;name&quot;: name,</span>
    <span class="c1">#                 &quot;type&quot;: &quot;&lt;&quot;,</span>
    <span class="c1">#                 &quot;value&quot;: xi,</span>
    <span class="c1">#                 &quot;target&quot;: ub_i,</span>
    <span class="c1">#                 &quot;satisfied&quot;: (ub_i - xi &gt;= -tol)  # xi ≤ ub_i</span>
    <span class="c1">#             })</span>

    <span class="c1">#     # Then concatenate in order:</span>
    <span class="c1">#     constraint_data = bounds_lower + bounds_upper + constraint_data</span>
    <span class="c1">#     print(constraint_data)</span>


    <span class="c1">#     # Build the report</span>
    <span class="c1">#     sep = &quot;-&quot; * 80</span>
    <span class="c1">#     lines = [</span>
    <span class="c1">#         &quot;&quot;,</span>
    <span class="c1">#         sep,</span>
    <span class="c1">#         f&quot; {&#39;Constraint summary report&#39;:&lt;{max_name_width}}{&#39;Value&#39;:&gt;12}{&#39;Target&#39;:&gt;13}{&#39;Ok?&#39;:&gt;6}{&#39;Multiplier&#39;:&gt;12}&quot;,</span>
    <span class="c1">#         sep,</span>
    <span class="c1">#     ]</span>

    <span class="c1">#     eq_count = 0</span>
    <span class="c1">#     ineq_count = 0</span>
    <span class="c1">#     for entry in constraint_data:</span>
    <span class="c1">#         name = entry.get(&quot;name&quot;, &quot;&quot;)</span>
    <span class="c1">#         ctype = entry.get(&quot;type&quot;, &quot;&quot;)</span>
    <span class="c1">#         value = entry.get(&quot;value&quot;, 0.0)</span>
    <span class="c1">#         target = entry.get(&quot;target&quot;, 0.0)</span>
    <span class="c1">#         satisfied = &quot;yes&quot; if entry.get(&quot;satisfied&quot;, False) else &quot; no&quot;</span>

    <span class="c1">#         if len(name) &gt; max_name_width:</span>
    <span class="c1">#             name = &quot;...&quot; + name[-(max_name_width - 3):]</span>

    <span class="c1">#         # Set the symbol for the target constraint</span>
    <span class="c1">#         if ctype == &quot;=&quot;:</span>
    <span class="c1">#             symbol = &quot;=&quot;</span>
    <span class="c1">#         elif ctype == &quot;&lt;&quot;:</span>
    <span class="c1">#             symbol = &quot;&lt;&quot;</span>
    <span class="c1">#         elif ctype == &quot;&gt;&quot;:</span>
    <span class="c1">#             symbol = &quot;&gt;&quot;</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             symbol = &quot;?&quot;</span>

    <span class="c1">#         value_str = f&quot;{value:+.3e}&quot;</span>
    <span class="c1">#         target_str = f&quot;{symbol} {target:+.3e}&quot;</span>

    <span class="c1">#         # Handle multipliers</span>
    <span class="c1">#         if ctype == &quot;=&quot;:</span>
    <span class="c1">#             multiplier = f&quot;{multipliers_eq[eq_count]:+.3e}&quot;</span>
    <span class="c1">#             eq_count += 1</span>
    <span class="c1">#         elif ctype in {&quot;&lt;&quot;, &quot;&gt;&quot;}:</span>
    <span class="c1">#             if ineq_count in active_multipliers:</span>
    <span class="c1">#                 multiplier = f&quot;{active_multipliers[ineq_count]:+.3e}&quot;</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 multiplier = &quot;inactive&quot;</span>
    <span class="c1">#             ineq_count += 1</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             multiplier = &quot;---&quot;</span>

    <span class="c1">#         lines.append(f&quot; {name:&lt;{max_name_width}}{value_str:&gt;12}{target_str:&gt;13}{satisfied:&gt;6}{multiplier:&gt;12}&quot;)</span>

    <span class="c1">#     lines.append(sep)</span>
    <span class="c1">#     return &quot;\n&quot;.join(lines)</span>


<div class="viewcode-block" id="OptimizationSolver.make_constraint_report">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver.make_constraint_report">[docs]</a>
    <span class="k">def</span> <span class="nf">make_constraint_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_norm</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        generate a formatted constraint report at x_phys,</span>
<span class="sd">        using get_constraint_data to build/validate the entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_name_width</span> <span class="o">=</span> <span class="mi">48</span>
        <span class="n">constraint_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constraint_data</span><span class="p">(</span><span class="n">x_norm</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

        <span class="c1"># from .pysolver_utilities import print_dict</span>
        <span class="c1"># print(&quot;Data dictionary&quot;)</span>
        <span class="c1"># for item in constraint_data:</span>
        <span class="c1">#     print()</span>
        <span class="c1">#     print_dict(item)</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39; Optimization constraints report&#39;</span><span class="si">:</span><span class="s2">&lt;80</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39; Constraint name&#39;</span><span class="si">:</span><span class="s2">&lt;49</span><span class="si">}{</span><span class="s1">&#39;Value&#39;</span><span class="si">:</span><span class="s2">&gt;11</span><span class="si">}{</span><span class="s1">&#39;Target&#39;</span><span class="si">:</span><span class="s2">&gt;13</span><span class="si">}{</span><span class="s1">&#39;Ok?&#39;</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">constraint_data</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">satisfied</span> <span class="o">=</span> <span class="s2">&quot;yes&quot;</span> <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;satisfied&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;no&quot;</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_name_width</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;...&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">max_name_width</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="p">:]</span>

            <span class="n">symbol_target</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ctype</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">target</span><span class="si">:</span><span class="s2">+.2e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="s2">&lt;48</span><span class="si">}{</span><span class="n">value</span><span class="si">:</span><span class="s2">&gt;+11.2e</span><span class="si">}{</span><span class="n">symbol_target</span><span class="si">:</span><span class="s2">&gt;13</span><span class="si">}{</span><span class="n">satisfied</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>



<div class="viewcode-block" id="OptimizationSolver.make_lagrange_multipliers_report">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationSolver.make_lagrange_multipliers_report">[docs]</a>
    <span class="k">def</span> <span class="nf">make_lagrange_multipliers_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_norm</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a report of all Lagrange multipliers:</span>
<span class="sd">        - Equalities: always included</span>
<span class="sd">        - Inequalities and bounds: show value if active, &#39;inactive&#39; otherwise</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The formatted multipliers report as a single string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute KKT data with given tolerance</span>
        <span class="n">kkt_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_kkt_conditions</span><span class="p">(</span><span class="n">x_norm</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">constraint_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_constraint_data</span><span class="p">(</span><span class="n">x_norm</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">eq_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">constraint_data</span> <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;=&quot;</span><span class="p">]</span>
        <span class="n">ineq_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">constraint_data</span> <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">]</span>
        <span class="c1"># TODO: add cases of ctype &quot;&gt;&quot;?</span>

        <span class="c1"># Print Lagrange multipliers in tabular format</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span>
        <span class="n">max_name_width</span> <span class="o">=</span> <span class="mi">48</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">sep</span><span class="p">,</span>
            <span class="s2">&quot; Lagrange multipliers report&quot;</span><span class="p">,</span>
            <span class="n">sep</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="s1">&#39;Multiplier for constraint&#39;</span><span class="si">:</span><span class="s2">&lt;</span><span class="si">{</span><span class="n">max_name_width</span><span class="si">}}{</span><span class="s1">&#39;Type&#39;</span><span class="si">:</span><span class="s2">&gt;15</span><span class="si">}{</span><span class="s1">&#39;Value&#39;</span><span class="si">:</span><span class="s2">&gt;15</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">sep</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="c1"># 1. Equality constraints</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eq_data</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="s2">&quot;equality&quot;</span>
            <span class="n">lam</span> <span class="o">=</span> <span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;multipliers_eq&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">valstr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lam</span><span class="si">:</span><span class="s2">+.3e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_name_width</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;...&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">max_name_width</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="p">:]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="s2">&lt;</span><span class="si">{</span><span class="n">max_name_width</span><span class="si">}}{</span><span class="n">ctype</span><span class="si">:</span><span class="s2">&gt;15</span><span class="si">}{</span><span class="n">valstr</span><span class="si">:</span><span class="s2">&gt;15</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># 2. Inequality + bound constraints</span>
        <span class="n">var_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">variable_names</span>
        <span class="n">n_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_names</span><span class="p">)</span>
        <span class="n">n_ineq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ineq_data</span><span class="p">)</span>
        <span class="n">total_ineq</span> <span class="o">=</span> <span class="n">n_ineq</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_vars</span>
        <span class="n">active</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kkt_data</span><span class="p">[</span><span class="s2">&quot;multipliers_ineq&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_ineq</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_ineq</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">ineq_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                <span class="n">ctype</span> <span class="o">=</span> <span class="s2">&quot;inequality&quot;</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_ineq</span> <span class="o">+</span> <span class="n">n_vars</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">n_ineq</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">var_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">ctype</span> <span class="o">=</span> <span class="s2">&quot;lower bound&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">n_ineq</span> <span class="o">-</span> <span class="n">n_vars</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">var_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">ctype</span> <span class="o">=</span> <span class="s2">&quot;upper bound&quot;</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_name_width</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;...&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">max_name_width</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="p">:]</span>

            <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">active</span><span class="p">:</span>
                <span class="n">valstr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">kkt_data</span><span class="p">[</span><span class="s1">&#39;multipliers_ineq&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="si">:</span><span class="s2">+.3e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">valstr</span> <span class="o">=</span> <span class="s2">&quot;inactive&quot;</span>

            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="s2">&lt;</span><span class="si">{</span><span class="n">max_name_width</span><span class="si">}}{</span><span class="n">ctype</span><span class="si">:</span><span class="s2">&gt;15</span><span class="si">}{</span><span class="n">valstr</span><span class="si">:</span><span class="s2">&gt;15</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="OptimizationProblem">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationProblem">[docs]</a>
<span class="k">class</span> <span class="nc">OptimizationProblem</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for optimization problems.</span>

<span class="sd">    Derived optimization problem objects must implement the following methods:</span>

<span class="sd">    - `fitness`: Evaluate the objective function and constraints for a given set of decision variables.</span>
<span class="sd">    - `get_bounds`: Get the bounds for each decision variable.</span>
<span class="sd">    - `get_neq`: Return the number of equality constraints associated with the problem.</span>
<span class="sd">    - `get_nineq`: Return the number of inequality constraints associated with the problem.</span>

<span class="sd">    Additionally, specific problem classes can define the `gradient` method to compute the Jacobians. If this method is not present in the derived class, the solver will revert to using forward finite differences for Jacobian calculations.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    fitness(x)</span>
<span class="sd">        Evaluate the objective function and constraints for a given set of decision variables.</span>
<span class="sd">    get_bounds()</span>
<span class="sd">        Get the bounds for each decision variable.</span>
<span class="sd">    get_neq()</span>
<span class="sd">        Return the number of equality constraints associated with the problem.</span>
<span class="sd">    get_nineq()</span>
<span class="sd">        Return the number of inequality constraints associated with the problem.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    problem_scale : float, optional</span>
<span class="sd">        Scaling factor for normalization. Default is 1.0.</span>
<span class="sd">    variable_names : list of str, optional</span>
<span class="sd">        Names of the decision variables. Used for reporting and debugging.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OptimizationProblem.fitness">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationProblem.fitness">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the objective function and constraints for given decision variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Vector of independent variables (i.e., degrees of freedom).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array_like</span>
<span class="sd">            Vector containing the objective function, equality constraints, and inequality constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="OptimizationProblem.get_bounds">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationProblem.get_bounds">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the bounds for each decision variable (Pygmo format)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bounds : tuple of lists</span>
<span class="sd">            A tuple of two items where the first item is the list of lower bounds and the second</span>
<span class="sd">            item of the list of upper bounds for the vector of decision variables. For example,</span>
<span class="sd">            ([-2 -1], [2, 1]) indicates that the first decision variable has bounds between</span>
<span class="sd">            -2 and 2, and the second has bounds between -1 and 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="OptimizationProblem.get_nec">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationProblem.get_nec">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_nec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of equality constraints associated with the problem.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        neq : int</span>
<span class="sd">            Number of equality constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="OptimizationProblem.get_nic">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationProblem.get_nic">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_nic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of inequality constraints associated with the problem.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nineq : int</span>
<span class="sd">            Number of inequality constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="OptimizationProblem.get_bounds_normalized">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationProblem.get_bounds_normalized">[docs]</a>
    <span class="k">def</span> <span class="nf">get_bounds_normalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return normalized bounds in [0, problem_scale]. If no scaling is applied (i.e., problem_scale is None),</span>
<span class="sd">        the physical bounds are returned instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple of lists</span>
<span class="sd">            Tuple (lb, ub) in normalized space or the original physical bounds if problem_scale is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">()</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">problem_scale</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span></div>


<div class="viewcode-block" id="OptimizationProblem.scale_physical_to_normalized">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationProblem.scale_physical_to_normalized">[docs]</a>
    <span class="k">def</span> <span class="nf">scale_physical_to_normalized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_phys</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert physical design variable values to normalized values in the range [0, problem_scale].</span>
<span class="sd">        If self.problem_scale is None, no scaling is applied.</span>

<span class="sd">        The method uses the bounds returned by `self.get_bounds()` and the internal `self.problem_scale`.</span>
<span class="sd">        It automatically handles the case of fixed variables (i.e., upper bound = lower bound) by returning 0.0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_phys : array-like</span>
<span class="sd">            Physical values of the decision variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Normalized values in the range [0, problem_scale] if scaling is applied,</span>
<span class="sd">            otherwise the original physical values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_phys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x_phys</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x_phys</span>
        <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">()</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
        <span class="n">x_scaled</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">lbi</span><span class="p">,</span> <span class="n">ubi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_phys</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ubi</span> <span class="o">==</span> <span class="n">lbi</span><span class="p">:</span>
                <span class="n">x_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">problem_scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="n">lbi</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ubi</span> <span class="o">-</span> <span class="n">lbi</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x_scaled</span><span class="p">)</span></div>


<div class="viewcode-block" id="OptimizationProblem.scale_normalized_to_physical">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationProblem.scale_normalized_to_physical">[docs]</a>
    <span class="k">def</span> <span class="nf">scale_normalized_to_physical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_norm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert normalized values in the range [0, problem_scale] back to physical variable values.</span>
<span class="sd">        If self.problem_scale is None, no scaling is applied.</span>

<span class="sd">        The method uses the bounds returned by `self.get_bounds()` and the internal `self.problem_scale`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_norm : array-like</span>
<span class="sd">            Normalized values of the decision variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Physical values corresponding to the normalized input, or the original values if no scaling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x_norm</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x_norm</span>
        <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">()</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lb</span> <span class="o">+</span> <span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="n">lb</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_norm</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_scale</span><span class="p">)</span></div>


<div class="viewcode-block" id="OptimizationProblem.fitness_normalized_input">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationProblem.fitness_normalized_input">[docs]</a>
    <span class="k">def</span> <span class="nf">fitness_normalized_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_norm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate fitness starting from normalized input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_norm : array-like</span>
<span class="sd">            Normalized input vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array_like</span>
<span class="sd">            Output of `fitness` evaluated on the corresponding physical vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_phys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_normalized_to_physical</span><span class="p">(</span><span class="n">x_norm</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span><span class="p">(</span><span class="n">x_phys</span><span class="p">)</span></div>


<div class="viewcode-block" id="OptimizationProblem.gradient_normalized_input">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationProblem.gradient_normalized_input">[docs]</a>
    <span class="k">def</span> <span class="nf">gradient_normalized_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_norm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the gradient of the objective and constraints with respect to normalized variables.</span>

<span class="sd">        This function applies the chain rule to convert the gradient computed in the physical space</span>
<span class="sd">        to the corresponding gradient in the normalized space. If `problem_scale` is set to `None`,</span>
<span class="sd">        the problem is considered unscaled and the gradient is returned directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_norm : array-like</span>
<span class="sd">            Normalized input vector (typically in [0, problem_scale]).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Gradient with respect to the normalized variables. The shape is:</span>
<span class="sd">            - (n,) for scalar objective or flat constraint vectors.</span>
<span class="sd">            - (m, n) for vector-valued constraints with m rows and n design variables.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The chain rule is applied as follows:</span>

<span class="sd">            x_phys = lb + (ub - lb) * (x_norm / problem_scale)</span>
<span class="sd">            ∇f(x_norm) = ∇f(x_phys) * d(x_phys)/d(x_norm)</span>

<span class="sd">        where:</span>

<span class="sd">            d(x_phys)/d(x_norm) = (ub - lb) / problem_scale    [elementwise]</span>

<span class="sd">        This correction ensures that exact user-defined gradients are consistent</span>
<span class="sd">        with the scaling applied during optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_phys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_normalized_to_physical</span><span class="p">(</span><span class="n">x_norm</span><span class="p">)</span>
        <span class="n">grad_phys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">x_phys</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grad_phys</span>

        <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">()</span>
        <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="n">lb</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_scale</span>

        <span class="c1"># Apply scaling using broadcasting to support both 1D and 2D gradients</span>
        <span class="k">return</span> <span class="n">grad_phys</span> <span class="o">*</span> <span class="n">scaling_factor</span></div>

    

<div class="viewcode-block" id="OptimizationProblem.clip_to_bounds">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.OptimizationProblem.clip_to_bounds">[docs]</a>
    <span class="k">def</span> <span class="nf">clip_to_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_physical</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clip physical variable values to lie within specified bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_physical : array-like</span>
<span class="sd">            Input vector in physical space.</span>
<span class="sd">        logger : logging.Logger or None, optional</span>
<span class="sd">            Logger for outputting warnings. If None, warnings are printed to standard output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Clipped vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">()</span>
        <span class="n">x_physical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x_physical</span><span class="p">)</span>
        <span class="n">x_clipped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x_physical</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x_physical</span><span class="p">,</span> <span class="n">x_clipped</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">orig</span> <span class="o">!=</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Warning: optimization variable out of bounds</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  Name       : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  Original   : </span><span class="si">{</span><span class="n">orig</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  Bounds     : [</span><span class="si">{</span><span class="n">low</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">high</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">]</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  Clipped to : </span><span class="si">{</span><span class="n">new</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">logger</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x_clipped</span></div>
</div>


<div class="viewcode-block" id="count_constraints">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.count_constraints">[docs]</a>
<span class="k">def</span> <span class="nf">count_constraints</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve the number of constraints based on the provided input.</span>

<span class="sd">    This function returns the count of constraints based on the nature of the</span>
<span class="sd">    input:</span>

<span class="sd">    - `None` returns 0</span>
<span class="sd">    - Scalar values return 1</span>
<span class="sd">    - Array-like structures return their length</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    var : None, scalar, or array-like (list, tuple, np.ndarray)</span>
<span class="sd">        The input representing the constraint(s). This can be `None`, a scalar value,</span>
<span class="sd">        or an array-like structure containing multiple constraints.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        The number of constraints:</span>

<span class="sd">        - 0 for `None`</span>
<span class="sd">        - 1 for scalar values</span>
<span class="sd">        - Length of the array-like for array-like inputs</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; count_constraints(None)</span>
<span class="sd">    0</span>

<span class="sd">    &gt;&gt;&gt; count_constraints(5.0)</span>
<span class="sd">    1</span>

<span class="sd">    &gt;&gt;&gt; count_constraints([1.0, 2.0, 3.0])</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If constraint is None</span>
    <span class="k">if</span> <span class="n">var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="c1"># If constraint is a scalar (assuming it&#39;s numeric)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="c1"># If constraint is array-like</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">)</span></div>



<div class="viewcode-block" id="combine_objective_and_constraints">
<a class="viewcode-back" href="../../source/api/pysolver_view.optimization.html#pysolver_view.optimization.combine_objective_and_constraints">[docs]</a>
<span class="k">def</span> <span class="nf">combine_objective_and_constraints</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c_eq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c_ineq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine an objective function with its associated equality and inequality constraints.</span>

<span class="sd">    This function takes in an objective function value, a set of equality constraints,</span>
<span class="sd">    and a set of inequality constraints. It then returns a combined Numpy array of</span>
<span class="sd">    these values. The constraints can be given as a list, tuple, numpy array, or as</span>
<span class="sd">    individual values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : float</span>
<span class="sd">        The value of the objective function.</span>
<span class="sd">    c_eq : float, list, tuple, np.ndarray, or None</span>
<span class="sd">        The equality constraint(s). This can be a single value or a collection of values.</span>
<span class="sd">        If `None`, no equality constraints will be added.</span>
<span class="sd">    c_ineq : float, list, tuple, np.ndarray, or None</span>
<span class="sd">        The inequality constraint(s). This can be a single value or a collection of values.</span>
<span class="sd">        If `None`, no inequality constraints will be added.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        A numpy array consisting of the objective function value followed by equality and</span>
<span class="sd">        inequality constraints.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; combine_objective_and_constraints(1.0, [0.5, 0.6], [0.7, 0.8])</span>
<span class="sd">    array([1. , 0.5, 0.6, 0.7, 0.8])</span>

<span class="sd">    &gt;&gt;&gt; combine_objective_and_constraints(1.0, 0.5, 0.7)</span>
<span class="sd">    array([1. , 0.5, 0.7])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Validate objective function value</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Objective function value &#39;f&#39; must be a scalar or single-element array.&quot;</span>
            <span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Unwrap the single element to ensure it&#39;s treated as a scalar</span>

    <span class="c1"># Add objective function</span>
    <span class="n">combined_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">]</span>

    <span class="c1"># Add equality constraints</span>
    <span class="k">if</span> <span class="n">c_eq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c_eq</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">combined_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">c_eq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">combined_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_eq</span><span class="p">)</span>

    <span class="c1"># Add inequality constraints</span>
    <span class="k">if</span> <span class="n">c_ineq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c_ineq</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">combined_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">c_ineq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">combined_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_ineq</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">combined_list</span><span class="p">)</span></div>



<span class="k">class</span> <span class="nc">_PygmoProblem</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper class for optimization problems to be compatible with Pygmo&#39;s need for deep-copiable problems.</span>
<span class="sd">    This class uses anonymous functions (lambda) to prevent issues with deep copying complex objects,</span>
<span class="sd">    (like Coolprop&#39;s AbstractState objects) which are not deep-copiable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped_problem</span><span class="p">):</span>
        <span class="c1"># Pygmo requires a flattened Jacobian for gradients, unlike SciPy&#39;s two-dimensional array.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">wrapped_problem</span><span class="o">.</span><span class="n">fitness</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">wrapped_problem</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># Directly link bounds and constraint counts from the original problem.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_bounds</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">wrapped_problem</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_bounds_normalized</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_nec</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">wrapped_problem</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_nec</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_nic</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">wrapped_problem</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_nic</span><span class="p">()</span>

        <span class="c1"># If the original problem defines Hessians, provide them as well.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wrapped_problem</span><span class="o">.</span><span class="n">problem</span><span class="p">,</span> <span class="s2">&quot;hessians&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hessians</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">wrapped_problem</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">hessians</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Define anonymous functions for objective and constraints with their Jacobians.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">wrapped_problem</span><span class="o">.</span><span class="n">fitness</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_eq</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">wrapped_problem</span><span class="o">.</span><span class="n">fitness</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nec</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_ineq</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">wrapped_problem</span><span class="o">.</span><span class="n">fitness</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nec</span><span class="p">()</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">f_jac</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">wrapped_problem</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_eq_jac</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">wrapped_problem</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nec</span><span class="p">(),</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_ineq_jac</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">wrapped_problem</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nec</span><span class="p">()</span> <span class="p">:,</span> <span class="p">:]</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Roberto Agromayor
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024, Roberto Agromayor.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>